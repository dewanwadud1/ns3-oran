/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/**
 * This file is developed by A. Wadud, Ph.D. Student, University College Dublin.
 *
 * Modified to also collect RSRP, RSRQ, and CQI dataset as trace files.
 *
 * NIST-developed software is provided by NIST as a public service. You may
 * use, copy and distribute copies of the software in any medium, provided that
 * you keep intact this entire notice. You may improve, modify and create
 * derivative works of the software or any portion of the software, and you may
 * copy and distribute such modifications or works. Modified works should carry
 * a notice stating that you changed the software and should note the date and
 * nature of any such change. Please explicitly acknowledge the National
 * Institute of Standards and Technology as the source of the software.
 *
 * (License and warranty disclaimer omitted for brevity.)
 */

#include "ns3/applications-module.h"
#include "ns3/core-module.h"
#include "ns3/internet-module.h"
#include "ns3/lte-module.h"
#include "ns3/mobility-module.h"
#include "ns3/oran-module.h"
#include "ns3/point-to-point-module.h"
#include <fstream>
#include <iostream>
#include <sstream>
#include <math.h>

using namespace ns3;

// Trace file names
static std::string s_trafficTraceFile = "traffic-trace.tr";
static std::string s_positionTraceFile = "position-trace.tr";
static std::string s_handoverTraceFile = "handover-trace.tr";
static std::string s_metricsTraceFile  = "metrics-trace.tr";

// Callback to trace RX packets
void
RxTrace (Ptr<const Packet> p, const Address & from, const Address & to)
{
  uint16_t ueId = (InetSocketAddress::ConvertFrom (to).GetPort () / 1000);
  std::ofstream rxOutFile (s_trafficTraceFile, std::ios_base::app);
  rxOutFile << Simulator::Now().GetSeconds() << " " << ueId << " RX " << p->GetSize() << std::endl;
}

// Callback to trace TX packets
void
TxTrace (Ptr<const Packet> p, const Address & from, const Address & to)
{
  uint16_t ueId = (InetSocketAddress::ConvertFrom (to).GetPort () / 1000);
  std::ofstream txOutFile (s_trafficTraceFile, std::ios_base::app);
  txOutFile << Simulator::Now().GetSeconds() << " " << ueId << " TX " << p->GetSize() << std::endl;
}

// Callback to trace positions of all nodes
void
TracePositions (NodeContainer nodes)
{
  std::ofstream posOutFile (s_positionTraceFile, std::ios_base::app);
  posOutFile << Simulator::Now().GetSeconds();
  for (uint32_t i = 0; i < nodes.GetN(); i++)
    {
      Vector pos = nodes.Get(i)->GetObject<MobilityModel>()->GetPosition();
      posOutFile << " " << pos.x << " " << pos.y;
    }
  posOutFile << std::endl;
  Simulator::Schedule (Seconds(1), &TracePositions, nodes);
}

// Callback for handover trace
void
NotifyHandoverEndOkEnb (std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti)
{
  std::ofstream hoOutFile (s_handoverTraceFile, std::ios_base::app);
  hoOutFile << Simulator::Now().GetSeconds() << " " << imsi << " " << cellid << " " << rnti << std::endl;
}

// --- New: Metrics Trace Callback ---
// This callback is invoked whenever the Near-RT RIC receives a report.
// It writes out a line to a metrics trace file for RSRP/RSRQ and CQI reports.

void
CqiTrace (Ptr<const OranReport> report)
{
  // Check that the report is of CQI type.
  if (report->GetInstanceTypeId() == TypeId::LookupByName("ns3::OranReportLteUeCqi"))
    {
      Ptr<const OranReportLteUeCqi> cqiRpt = report->GetObject<const OranReportLteUeCqi>();
      std::ofstream cqiOutFile("cqi-trace.tr", std::ios_base::app);
      cqiOutFile << Simulator::Now().GetSeconds() << " CQI "
                 << cqiRpt->GetReporterE2NodeId() << " "
                 << cqiRpt->GetRnti() << " "
                 << cqiRpt->GetCellId() << " "
                 << static_cast<uint32_t>(cqiRpt->GetCqi()) << " "
                 << cqiRpt->GetComponentCarrierId() << std::endl;
      cqiOutFile.close();
    }
}

void
MetricsTrace (Ptr<const OranReport> report)
{
  std::ofstream metricsOutFile (s_metricsTraceFile, std::ios_base::app);
  double now = Simulator::Now().GetSeconds();

  // Check for RSRP/RSRQ report type.
  if (report->GetInstanceTypeId() == TypeId::LookupByName("ns3::OranReportLteUeRsrpRsrq"))
    {
      Ptr<const OranReportLteUeRsrpRsrq> rsrpRpt = report->GetObject<const OranReportLteUeRsrpRsrq>();
      metricsOutFile << now << " RSRP_RSRQ "
                     << rsrpRpt->GetReporterE2NodeId() << " "
                     << rsrpRpt->GetRnti() << " "
                     << rsrpRpt->GetCellId() << " "
                     << rsrpRpt->GetRsrp() << " "
                     << rsrpRpt->GetRsrq() << " "
                     << rsrpRpt->GetIsServingCell() << " "
                     << rsrpRpt->GetComponentCarrierId() << std::endl;
    }
  // Check for CQI report type.
  else if (report->GetInstanceTypeId() == TypeId::LookupByName("ns3::OranReportLteUeCqi"))
    {
      Ptr<const OranReportLteUeCqi> cqiRpt = report->GetObject<const OranReportLteUeCqi>();
      metricsOutFile << now << " CQI "
                     << cqiRpt->GetReporterE2NodeId() << " "
                     << cqiRpt->GetRnti() << " "
                     << cqiRpt->GetCellId() << " "
                     << static_cast<uint32_t>(cqiRpt->GetCqi()) << " "
                     << cqiRpt->GetComponentCarrierId() << std::endl;
    }
  metricsOutFile.close();
}

NS_LOG_COMPONENT_DEFINE ("OranLte2LteMlHandoverExample");

int
main (int argc, char *argv[])
{
  bool verbose = false;
  bool useOran = true;
  bool useOnnx = false;
  bool useTorch = false;
  bool useDistance = false;
  uint32_t startConfig = 1;
  double lmQueryInterval = 1;
  double txDelay = 0;
  std::string handoverAlgorithm = "ns3::NoOpHandoverAlgorithm";
  Time simTime = Seconds (100);
  std::string dbFileName = "oran-repository.db";

  CommandLine cmd;
  cmd.AddValue ("verbose", "Enable printing SQL queries results", verbose);
  cmd.AddValue ("use-oran", "Indicates whether ORAN should be used or not", useOran);
  cmd.AddValue ("use-onnx-lm", "Indicates whether the ONNX LM should be used or not", useOnnx);
  cmd.AddValue ("use-torch-lm", "Indicates whether the PyTorch LM should be used or not", useTorch);
  cmd.AddValue ("use-distance-lm", "Indicates whether the distance LM should be used or not", useDistance);
  cmd.AddValue ("start-config", "The starting configuration", startConfig);
  cmd.AddValue ("sim-time", "The duration for which traffic should flow", simTime);
  cmd.AddValue ("lm-query-interval", "The LM query interval", lmQueryInterval);
  cmd.AddValue ("tx-delay", "The E2 terminator's transmission delay", txDelay);
  cmd.AddValue ("handover-algorithm", "Specify which handover algorithm to use", handoverAlgorithm);
  cmd.AddValue ("db-file", "Specify the DB file to create", dbFileName);
  cmd.AddValue ("traffic-trace-file", "Specify the traffic trace file to create", s_trafficTraceFile);
  cmd.AddValue ("position-trace-file", "Specify the position trace file to create", s_positionTraceFile);
  cmd.AddValue ("handover-trace-file", "Specify the handover trace file to create", s_handoverTraceFile);
  cmd.Parse (argc, argv);

  NS_ABORT_MSG_IF (useOran == false && (useOnnx || useTorch || useDistance),
                   "Cannot use ML LM or distance LM without enabling O-RAN.");
  NS_ABORT_MSG_IF ((useOnnx + useTorch + useDistance) > 1,
                   "Cannot use more than one LM simultaneously.");
  NS_ABORT_MSG_IF (handoverAlgorithm != "ns3::NoOpHandoverAlgorithm" &&
                   (useOnnx || useTorch || useDistance),
                   "Cannot use non-noop handover algorithm with ML LM or distance LM.");

  // Increase the buffer size to accommodate the application demand
  Config::SetDefault ("ns3::LteRlcUm::MaxTxBufferSize", UintegerValue (1000 * 1024));
  // Disable automatic cell reselection when signal quality is bad.
  Config::SetDefault ("ns3::LteUePhy::EnableRlfDetection", BooleanValue (false));

  // Configure LTE parameters
  Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
  lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::Cost231PropagationLossModel"));
  lteHelper->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (50));
  lteHelper->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (50));
  lteHelper->SetSchedulerType ("ns3::RrFfMacScheduler");
  lteHelper->SetSchedulerAttribute ("HarqEnabled", BooleanValue (true));
  lteHelper->SetHandoverAlgorithmType (handoverAlgorithm);

  // Deploy EPC
  Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper> ();
  lteHelper->SetEpcHelper (epcHelper);

  Ptr<Node> pgw = epcHelper->GetPgwNode ();

  // Create a remote host
  NodeContainer remoteHostContainer;
  remoteHostContainer.Create (1);
  Ptr<Node> remoteHost = remoteHostContainer.Get (0);
  InternetStackHelper internet;
  internet.Install (remoteHostContainer);

  // IP configuration for remote host
  PointToPointHelper p2ph;
  p2ph.SetDeviceAttribute ("DataRate", DataRateValue (DataRate ("100Gb/s")));
  p2ph.SetDeviceAttribute ("Mtu", UintegerValue (65000));
  p2ph.SetChannelAttribute ("Delay", TimeValue (MilliSeconds (0)));
  NetDeviceContainer internetDevices = p2ph.Install (pgw, remoteHost);
  Ipv4AddressHelper ipv4h;
  ipv4h.SetBase ("1.0.0.0", "255.0.0.0");
  Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign (internetDevices);

  Ipv4StaticRoutingHelper ipv4RoutingHelper;
  Ptr<Ipv4StaticRouting> remoteHostStaticRouting =
    ipv4RoutingHelper.GetStaticRouting (remoteHost->GetObject<Ipv4>());
  remoteHostStaticRouting->AddNetworkRouteTo (Ipv4Address ("7.0.0.0"), Ipv4Mask ("255.0.0.0"), 1);

  // Create eNB and UE nodes
  NodeContainer ueNodes;
  NodeContainer enbNodes;
  enbNodes.Create (2);
  ueNodes.Create (4);

  // Set up mobility for eNBs
  Ptr<ListPositionAllocator> positionAllocEnbs = CreateObject<ListPositionAllocator> ();
  positionAllocEnbs->Add (Vector (0, 0, 0));
  positionAllocEnbs->Add (Vector (265, 0, 0));
  MobilityHelper mobilityEnbs;
  mobilityEnbs.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
  mobilityEnbs.SetPositionAllocator (positionAllocEnbs);
  mobilityEnbs.Install (enbNodes);

  // Set up mobility for UEs (constant positions)
  Ptr<ListPositionAllocator> positionAllocUes = CreateObject<ListPositionAllocator> ();
  positionAllocUes->Add (Vector (100, 0, 0));
  positionAllocUes->Add (Vector (190, 0, 0));
  positionAllocUes->Add (Vector (210, 0, 0));
  positionAllocUes->Add (Vector (300, 0, 0));
  MobilityHelper mobilityUes;
  // For simplicity, using constant positions here; you can also use a random mobility model.
  mobilityUes.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
  mobilityUes.SetPositionAllocator (positionAllocUes);
  mobilityUes.Install (ueNodes);

  // Install LTE devices
  NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice (enbNodes);
  NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice (ueNodes);

  internet.Install (ueNodes);
  Ipv4InterfaceContainer ueIpIface = epcHelper->AssignUeIpv4Address (NetDeviceContainer (ueLteDevs));
  // Configure default routes for UEs
  for (uint32_t u = 0; u < ueNodes.GetN (); ++u)
    {
      Ptr<Node> ueNode = ueNodes.Get (u);
      Ptr<Ipv4StaticRouting> ueStaticRouting =
        ipv4RoutingHelper.GetStaticRouting (ueNode->GetObject<Ipv4>());
      ueStaticRouting->SetDefaultRoute (epcHelper->GetUeDefaultGatewayAddress (), 1);
    }

  // Attach UEs to eNBs based on startConfig
  switch (startConfig)
    {
    case 0:
      lteHelper->Attach (ueLteDevs.Get (0), enbLteDevs.Get (0));
      lteHelper->Attach (ueLteDevs.Get (1), enbLteDevs.Get (0));
      lteHelper->Attach (ueLteDevs.Get (2), enbLteDevs.Get (0));
      lteHelper->Attach (ueLteDevs.Get (3), enbLteDevs.Get (1));
      break;
    case 1:
      lteHelper->Attach (ueLteDevs.Get (0), enbLteDevs.Get (0));
      lteHelper->Attach (ueLteDevs.Get (1), enbLteDevs.Get (0));
      lteHelper->Attach (ueLteDevs.Get (2), enbLteDevs.Get (1));
      lteHelper->Attach (ueLteDevs.Get (3), enbLteDevs.Get (1));
      break;
    case 2:
      lteHelper->Attach (ueLteDevs.Get (0), enbLteDevs.Get (0));
      lteHelper->Attach (ueLteDevs.Get (1), enbLteDevs.Get (1));
      lteHelper->Attach (ueLteDevs.Get (2), enbLteDevs.Get (0));
      lteHelper->Attach (ueLteDevs.Get (3), enbLteDevs.Get (1));
      break;
    case 3:
      lteHelper->Attach (ueLteDevs.Get (0), enbLteDevs.Get (0));
      lteHelper->Attach (ueLteDevs.Get (1), enbLteDevs.Get (1));
      lteHelper->Attach (ueLteDevs.Get (2), enbLteDevs.Get (1));
      lteHelper->Attach (ueLteDevs.Get (3), enbLteDevs.Get (1));
      break;
    default:
      NS_ABORT_MSG ("Starting configuration " << startConfig << " not supported.");
      break;
    }

  lteHelper->AddX2Interface (enbNodes);

  // Install and start applications on UEs and remote host
  uint16_t basePort = 1000;
  ApplicationContainer remoteApps;
  ApplicationContainer ueApps;

  Ptr<RandomVariableStream> onTimeRv = CreateObject<UniformRandomVariable> ();
  onTimeRv->SetAttribute ("Min", DoubleValue (1.0));
  onTimeRv->SetAttribute ("Max", DoubleValue (5.0));
  Ptr<RandomVariableStream> offTimeRv = CreateObject<UniformRandomVariable> ();
  offTimeRv->SetAttribute ("Min", DoubleValue (1.0));
  offTimeRv->SetAttribute ("Max", DoubleValue (5.0));

  for (uint16_t i = 0; i < ueNodes.GetN (); i++)
    {
      uint16_t port = basePort * (i + 1);
      PacketSinkHelper dlPacketSinkHelper ("ns3::UdpSocketFactory",
                                             InetSocketAddress (Ipv4Address::GetAny (), port));
      ueApps.Add (dlPacketSinkHelper.Install (ueNodes.Get (i)));
      ueApps.Get (i)->TraceConnectWithoutContext ("RxWithAddresses", MakeCallback (&RxTrace));

      Ptr<OnOffApplication> streamingServer = CreateObject<OnOffApplication> ();
      remoteApps.Add (streamingServer);
      streamingServer->SetAttribute ("Remote",
                                       AddressValue (InetSocketAddress (ueIpIface.GetAddress (i), port)));
      streamingServer->SetAttribute ("DataRate", DataRateValue (DataRate ("3000000bps")));
      streamingServer->SetAttribute ("PacketSize", UintegerValue (1500));
      streamingServer->SetAttribute ("OnTime", PointerValue (onTimeRv));
      streamingServer->SetAttribute ("OffTime", PointerValue (offTimeRv));
      remoteHost->AddApplication (streamingServer);
      streamingServer->TraceConnectWithoutContext ("TxWithAddresses", MakeCallback (&TxTrace));
    }

  remoteApps.Start (Seconds (2));
  remoteApps.Stop (simTime + Seconds (10));
  ueApps.Start (Seconds (1));
  ueApps.Stop (simTime + Seconds (15));

  // ORAN BEGIN
  if (useOran)
    {
      if (!dbFileName.empty ())
        {
          std::remove (dbFileName.c_str ());
        }
      TypeId defaultLmTid = TypeId::LookupByName ("ns3::OranLmNoop");

      Ptr<OranLm> defaultLm = nullptr;
      Ptr<OranDataRepository> dataRepository = CreateObject<OranDataRepositorySqlite> ();
      Ptr<OranCmm> cmm = CreateObject<OranCmmHandover> ();
      Ptr<OranNearRtRic> nearRtRic = CreateObject<OranNearRtRic> ();
      Ptr<OranNearRtRicE2Terminator> nearRtRicE2Terminator = CreateObject<OranNearRtRicE2Terminator> ();

      if (useOnnx)
        {
          NS_ABORT_MSG_IF (!TypeId::LookupByNameFailSafe ("ns3::OranLmLte2LteOnnxHandover", &defaultLmTid),
                           "ONNX LM not found.");
        }
      else if (useTorch)
        {
          NS_ABORT_MSG_IF (!TypeId::LookupByNameFailSafe ("ns3::OranLmLte2LteTorchHandover", &defaultLmTid),
                           "Torch LM not found.");
        }
      else if (useDistance)
        {
          defaultLmTid = TypeId::LookupByName ("ns3::OranLmLte2LteDistanceHandover");
        }

      ObjectFactory defaultLmFactory;
      defaultLmFactory.SetTypeId (defaultLmTid);
      defaultLm = defaultLmFactory.Create<OranLm> ();

      dataRepository->SetAttribute ("DatabaseFile", StringValue (dbFileName));
      defaultLm->SetAttribute ("Verbose", BooleanValue (verbose));
      defaultLm->SetAttribute ("NearRtRic", PointerValue (nearRtRic));

      cmm->SetAttribute ("NearRtRic", PointerValue (nearRtRic));

      nearRtRicE2Terminator->SetAttribute ("NearRtRic", PointerValue (nearRtRic));
      nearRtRicE2Terminator->SetAttribute ("DataRepository", PointerValue (dataRepository));
      nearRtRicE2Terminator->SetAttribute ("TransmissionDelayRv",
                                            StringValue ("ns3::ConstantRandomVariable[Constant=" +
                                                         std::to_string (txDelay) + "]"));

      nearRtRic->SetAttribute ("DefaultLogicModule", PointerValue (defaultLm));
      nearRtRic->SetAttribute ("E2Terminator", PointerValue (nearRtRicE2Terminator));
      nearRtRic->SetAttribute ("DataRepository", PointerValue (dataRepository));
      nearRtRic->SetAttribute ("LmQueryInterval", TimeValue (Seconds (lmQueryInterval)));
      nearRtRic->SetAttribute ("ConflictMitigationModule", PointerValue (cmm));

      // The generic metrics trace as before:
      nearRtRic->TraceConnectWithoutContext("ReportReceived", MakeCallback(&MetricsTrace));
      // Connecting a dedicated CQI trace:
      nearRtRic->TraceConnectWithoutContext("ReportReceived", MakeCallback(&CqiTrace));

      Simulator::Schedule (Seconds (1), &OranNearRtRic::Start, nearRtRic);

      for (uint32_t idx = 0; idx < ueNodes.GetN (); idx++)
        {
          Ptr<OranReporterLocation> locationReporter = CreateObject<OranReporterLocation> ();
          Ptr<OranReporterLteUeCellInfo> lteUeCellInfoReporter = CreateObject<OranReporterLteUeCellInfo> ();
          Ptr<OranReporterAppLoss> appLossReporter = CreateObject<OranReporterAppLoss> ();
          Ptr<OranReporterLteUeRsrpRsrq> rsrpReporter = CreateObject<OranReporterLteUeRsrpRsrq> ();
          Ptr<OranReporterLteUeCqi> cqiReporter = CreateObject<OranReporterLteUeCqi> ();
          Ptr<OranE2NodeTerminatorLteUe> lteUeTerminator = CreateObject<OranE2NodeTerminatorLteUe> ();

          locationReporter->SetAttribute ("Terminator", PointerValue (lteUeTerminator));
          lteUeCellInfoReporter->SetAttribute ("Terminator", PointerValue (lteUeTerminator));
          appLossReporter->SetAttribute ("Terminator", PointerValue (lteUeTerminator));
          rsrpReporter->SetAttribute ("Terminator", PointerValue (lteUeTerminator));
          cqiReporter->SetAttribute ("Terminator", PointerValue (lteUeTerminator));

          remoteApps.Get (idx)->TraceConnectWithoutContext ("Tx",
              MakeCallback (&OranReporterAppLoss::AddTx, appLossReporter));
          ueApps.Get (idx)->TraceConnectWithoutContext ("Rx",
              MakeCallback (&OranReporterAppLoss::AddRx, appLossReporter));

          lteUeTerminator->SetAttribute ("NearRtRic", PointerValue (nearRtRic));
          lteUeTerminator->SetAttribute ("RegistrationIntervalRv",
                                         StringValue ("ns3::ConstantRandomVariable[Constant=1]"));
          lteUeTerminator->SetAttribute ("SendIntervalRv",
                                         StringValue ("ns3::ConstantRandomVariable[Constant=1]"));

          lteUeTerminator->AddReporter (locationReporter);
          lteUeTerminator->AddReporter (lteUeCellInfoReporter);
          lteUeTerminator->AddReporter (appLossReporter);
          lteUeTerminator->AddReporter (rsrpReporter);
          lteUeTerminator->AddReporter (cqiReporter);
          lteUeTerminator->SetAttribute ("TransmissionDelayRv",
                                         StringValue ("ns3::ConstantRandomVariable[Constant=" +
                                                      std::to_string (txDelay) + "]"));

          lteUeTerminator->Attach (ueNodes.Get (idx));

          Simulator::Schedule (Seconds (1), &OranE2NodeTerminatorLteUe::Activate, lteUeTerminator);
        }

      for (uint32_t idx = 0; idx < enbNodes.GetN (); idx++)
        {
          Ptr<OranReporterLocation> locationReporter = CreateObject<OranReporterLocation> ();
          Ptr<OranE2NodeTerminatorLteEnb> lteEnbTerminator = CreateObject<OranE2NodeTerminatorLteEnb> ();

          locationReporter->SetAttribute ("Terminator", PointerValue (lteEnbTerminator));

          lteEnbTerminator->SetAttribute ("NearRtRic", PointerValue (nearRtRic));
          lteEnbTerminator->SetAttribute ("RegistrationIntervalRv",
                                          StringValue ("ns3::ConstantRandomVariable[Constant=1]"));
          lteEnbTerminator->SetAttribute ("SendIntervalRv",
                                          StringValue ("ns3::ConstantRandomVariable[Constant=1]"));

          lteEnbTerminator->AddReporter (locationReporter);
          lteEnbTerminator->Attach (enbNodes.Get (idx));
          lteEnbTerminator->SetAttribute ("TransmissionDelayRv",
                                          StringValue ("ns3::ConstantRandomVariable[Constant=" +
                                                       std::to_string (txDelay) + "]"));
          Simulator::Schedule (Seconds (1), &OranE2NodeTerminatorLteEnb::Activate, lteEnbTerminator);
        }
    }
  // ORAN END

  // Erase (truncate) the trace files if they exist
  {
    std::ofstream trafficOutFile (s_trafficTraceFile, std::ios_base::trunc);
    trafficOutFile.close ();
    std::ofstream posOutFile (s_positionTraceFile, std::ios_base::trunc);
    posOutFile.close ();
    std::ofstream hoOutFile (s_handoverTraceFile, std::ios_base::trunc);
    hoOutFile.close ();
    std::ofstream metricsOutFile (s_metricsTraceFile, std::ios_base::trunc);
    metricsOutFile.close ();
  }

  // Start tracing node positions
  Simulator::Schedule (Seconds (1), &TracePositions, ueNodes);

  // Connect handover trace (for eNB)
  Config::Connect ("/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk",
                   MakeCallback (&NotifyHandoverEndOkEnb));

  Simulator::Stop (simTime + Seconds (20));
  Simulator::Run ();
  Simulator::Destroy ();

  return 0;
}

