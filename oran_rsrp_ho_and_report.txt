diff --git a/examples/diffMobilityApplicationExp.cc b/examples/diffMobilityApplicationExp.cc
index 94bba4c..2fbe99a 100644
--- a/examples/diffMobilityApplicationExp.cc
+++ b/examples/diffMobilityApplicationExp.cc
@@ -239,7 +239,7 @@
      double txPower = 30.0; // default TxPower in dBm
      cmd.AddValue("txPower", "eNB TxPower in dBm", txPower);
      
-     uint16_t numberOfUes = 10;
+     uint16_t numberOfUes = 50;
      uint16_t numberOfEnbs = 2;
      Time simTime = Seconds(10);
      Time maxWaitTime = Seconds(0.010);
diff --git a/examples/example-oran-ru-energy.cc b/examples/example-oran-ru-energy.cc
index b61d43c..4f1972c 100644
--- a/examples/example-oran-ru-energy.cc
+++ b/examples/example-oran-ru-energy.cc
@@ -79,7 +79,7 @@
  *
  * ---------- Triggering Handovers quickly (for demos) ----------
  *
- * K) Smaller cells and longer run (more HOs without xApp/BS toggling):
+ * K) Smaller cells and longer run (more HOs without xApp/BS toggling): [doesn't work at this moment, have to add some code]
  *    ./ns3 run "example-oran-ru-energy \
  *         --ringSites=7 --includeCenter=1 --isd=300 --uePerSite=9 \
  *         --usePaperMix=1 --simTime=120 --areaMin=-800 --areaMax=800"
@@ -117,6 +117,8 @@
 #include "ns3/oran-ru-energy-model.h"   // if integrated as a contrib module
 // #include "oran-ru-energy-model.h"    // use this line instead for quick test in scratch/
 
+#include <ns3/oran-module.h>
+
 #include <vector>
 #include <algorithm>
 #include <sstream>
@@ -167,6 +169,16 @@ ReverseVelocity (NodeContainer nodes, Time interval)
   Simulator::Schedule (interval, &ReverseVelocity, nodes, interval);
 }
 
+static void QueryRcSink(std::string query, std::string args, int rc)
+{
+  std::cout << Simulator::Now().GetSeconds() << " Query "
+            << ((rc == SQLITE_OK || rc == SQLITE_DONE) ? "OK" : "ERROR")
+            << "(" << rc << "): \"" << query << "\"";
+  if (!args.empty()) std::cout << " (" << args << ")";
+  std::cout << std::endl;
+}
+
+
 int
 main (int argc, char *argv[])
 {
@@ -230,6 +242,9 @@ main (int argc, char *argv[])
   double busFrac   = 0.10;   // buses
   double trainFrac = 0.05;   // trains / high-speed
 
+  // Application container variables 
+  ApplicationContainer ueApps, remoteApps;
+
 
 
   CommandLine cmd (__FILE__);
@@ -294,14 +309,16 @@ main (int argc, char *argv[])
     }
 
   // --------------------- LTE/EPC helpers ---------------------
-  Config::SetDefault ("ns3::LteHelper::UseIdealRrc", BooleanValue (false));
+  Config::SetDefault ("ns3::LteHelper::UseIdealRrc", BooleanValue (true));
   Ptr<LteHelper> lte = CreateObject<LteHelper> ();
   Ptr<PointToPointEpcHelper> epc = CreateObject<PointToPointEpcHelper> ();
   lte->SetEpcHelper (epc);
 
-  Config::SetDefault("ns3::A3RsrpHandoverAlgorithm::Hysteresis", DoubleValue(3.0));
-  Config::SetDefault("ns3::A3RsrpHandoverAlgorithm::TimeToTrigger", TimeValue(MilliSeconds(256)));
-  lte->SetHandoverAlgorithmType ("ns3::A3RsrpHandoverAlgorithm"); // natural HOs with motion
+  // Config::SetDefault("ns3::A3RsrpHandoverAlgorithm::Hysteresis", DoubleValue(3.0));
+  // Config::SetDefault("ns3::A3RsrpHandoverAlgorithm::TimeToTrigger", TimeValue(MilliSeconds(256)));
+  // lte->SetHandoverAlgorithmType ("ns3::A3RsrpHandoverAlgorithm"); // natural HOs with motion
+  lte->SetHandoverAlgorithmType("ns3::NoOpHandoverAlgorithm"); // disable automatic handover
+
   //lte->SetSchedulerType ("ns3::RrFfMacScheduler");                 // RR MAC
   // wider channel (paper uses 20 MHz => 100 RB)
   // ---- Single-carrier LTE, 20 MHz, consistent across *all* nodes ----
@@ -309,6 +326,10 @@ main (int argc, char *argv[])
   const uint16_t dlEarfcn = 2450;     // pick any FR1-ish EARFCN; must be consistent!
   const uint16_t ulEarfcn = 20450;
 
+  // Config::SetDefault("ns3::LteHelper::UseCa", BooleanValue(false));
+  // lte->SetEnbDeviceAttribute("NumberOfComponentCarriers", UintegerValue(1));
+  // lte->SetUeDeviceAttribute ("NumberOfComponentCarriers", UintegerValue(1));
+
   lte->SetEnbDeviceAttribute ("DlBandwidth", UintegerValue (rb20MHz));
   lte->SetEnbDeviceAttribute ("UlBandwidth", UintegerValue (rb20MHz));
   lte->SetEnbDeviceAttribute ("DlEarfcn",    UintegerValue (dlEarfcn));
@@ -640,7 +661,6 @@ main (int argc, char *argv[])
   // --------------------- Traffic ---------------------
   if (usePaperMix)
   {
-    ApplicationContainer ueApps, remoteApps;
     uint16_t portBase = 20000;
     uint32_t N = ueNodes.GetN();
     NS_ABORT_MSG_IF(N == 0, "No UEs to apply paper mix");
@@ -741,7 +761,6 @@ main (int argc, char *argv[])
   else
   {
     // keep your existing traffic profiles (eMBB/URLLC/V2X/mMTC/mixed) block here
-    ApplicationContainer ueApps, remoteApps; // sinks on both sides
     uint16_t basePort = 10000;
 
     auto rvStr = [](const std::string& kind, double meanSec)
@@ -891,7 +910,7 @@ main (int argc, char *argv[])
 
   // --------------------- Energy Model wiring ---------------------
   BasicEnergySourceHelper sourceHelper;
-  sourceHelper.Set ("BasicEnergySourceInitialEnergyJ", DoubleValue (500000.0)); // 0.5 MJ headroom
+  sourceHelper.Set ("BasicEnergySourceInitialEnergyJ", DoubleValue (50000000.0)); // 0.8 MJ headroom
   sourceHelper.Set ("BasicEnergySupplyVoltageV", DoubleValue (48.0)); // must match RU Vdc
   EnergySourceContainer sources = sourceHelper.Install (enbNodes);
 
@@ -924,6 +943,155 @@ main (int argc, char *argv[])
       src->AppendDeviceEnergyModel (dem);
       enbEnergyModels.push_back (dem);
     }
+  
+  // --------------------- ORAN (RIC + xApps) ---------------------
+  // --------------------- ORAN Models -- BEGIN (after energy wiring, before tracing) ---------------------
+  Ptr<OranNearRtRic> nearRtRic = nullptr;
+  OranE2NodeTerminatorContainer e2NodeTerminatorsEnbs;
+  OranE2NodeTerminatorContainer e2NodeTerminatorsUes;
+  Ptr<OranHelper> oranHelper = CreateObject<OranHelper>();
+
+  // Tunables (use your existing variables if you already defined them)
+  Time        lmQueryInterval   = Seconds(2.0);
+  Time        maxWaitTime       = Seconds(0.0); // 0 => wait for all LMs to finish
+  std::string lateCommandPolicy = "DROP";
+  std::string dbFileName        = "oran.sqlite";
+  bool        dbLog             = false;
+
+  oranHelper->SetAttribute("Verbose", BooleanValue(true));
+  oranHelper->SetAttribute("LmQueryInterval", TimeValue(lmQueryInterval));
+  oranHelper->SetAttribute("E2NodeInactivityThreshold", TimeValue(Seconds(10)));
+  oranHelper->SetAttribute("E2NodeInactivityIntervalRv",
+                          StringValue("ns3::ConstantRandomVariable[Constant=10]"));
+  oranHelper->SetAttribute("LmQueryMaxWaitTime", TimeValue(maxWaitTime));
+  oranHelper->SetAttribute("LmQueryLateCommandPolicy", StringValue(lateCommandPolicy));
+
+  // Fresh DB each run (optional)
+  if (!dbFileName.empty()) { std::remove(dbFileName.c_str()); }
+  oranHelper->SetDataRepository("ns3::OranDataRepositorySqlite",
+                                "DatabaseFile", StringValue(dbFileName));
+
+  // xApps / LMs
+  oranHelper->SetDefaultLogicModule("ns3::OranLmLte2LteRsrpHandover",
+                                    "ProcessingDelayRv",
+                                    StringValue("ns3::ExponentialRandomVariable[Mean=0.02]"));
+
+  // // Your energy-saving LM (xApp)
+  // oranHelper->SetDefaultLogicModule("ns3::OranLmLte2LteEnergySaving",
+  //   "TargetEfficiency", DoubleValue(1e3),   // tune for your scenario
+  //   "StepSize",        DoubleValue(1.0));  // e.g., 0.5–1.0 dB per tick
+
+
+
+  oranHelper->SetConflictMitigationModule("ns3::OranCmmNoop");
+
+  // Your energy-saving LM (xApp)
+  oranHelper->AddLogicModule("ns3::OranLmLte2LteEnergySaving",
+      "TargetEfficiency", DoubleValue(1e3),   // tune for your scenario
+      "StepSize",        DoubleValue(1.0));  // e.g., 0.5–1.0 dB per tick
+  
+  
+
+
+  nearRtRic = oranHelper->CreateNearRtRic();
+
+  // ---------------- eNB E2 Nodes + reporters ----------------
+  oranHelper->SetE2NodeTerminator("ns3::OranE2NodeTerminatorLteEnb",
+                                  "RegistrationIntervalRv",
+                                  StringValue("ns3::ConstantRandomVariable[Constant=1]"),
+                                  "SendIntervalRv",
+                                  StringValue("ns3::ConstantRandomVariable[Constant=1]"));
+
+  // We KEEP manual reporters (and thus REMOVE the helper-wide AddReporter(...) for EE)
+  // (If you prefer helper-wide auto reporters, delete the loop below and re-add AddReporter above.)
+  oranHelper->AddReporter("ns3::OranReporterLocation",
+                          "Trigger", StringValue("ns3::OranReportTriggerPeriodic"));
+
+  e2NodeTerminatorsEnbs.Add(oranHelper->DeployTerminators(nearRtRic, enbNodes));
+
+  // Attach one energy-efficiency reporter per eNB terminator (manual, no duplicates).
+  std::vector<Ptr<OranReporterLteEnergyEfficiency>> enbEeReporters;
+  enbEeReporters.reserve(enbNodes.GetN());
+  for (auto it = e2NodeTerminatorsEnbs.Begin(); it != e2NodeTerminatorsEnbs.End(); ++it)
+  {
+    Ptr<OranE2NodeTerminatorLteEnb> enbTerm = DynamicCast<OranE2NodeTerminatorLteEnb>(*it);
+    Ptr<OranReporterLteEnergyEfficiency> rpt = CreateObject<OranReporterLteEnergyEfficiency>();
+    rpt->SetAttribute("Terminator", PointerValue(enbTerm));
+    enbTerm->AddReporter(rpt);
+    enbEeReporters.push_back(rpt);
+  }
+
+  // ---------------- UE E2 Nodes + reporters (for RSRP to RIC) ----------------
+  for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)
+  {
+    Ptr<OranE2NodeTerminatorLteUe> lteUeTerminator = CreateObject<OranE2NodeTerminatorLteUe>();
+    lteUeTerminator->SetAttribute("NearRtRic", PointerValue(nearRtRic));
+    lteUeTerminator->SetAttribute("RegistrationIntervalRv",
+                                  StringValue("ns3::ConstantRandomVariable[Constant=1]"));
+    lteUeTerminator->SetAttribute("SendIntervalRv",
+                                  StringValue("ns3::ConstantRandomVariable[Constant=1]"));
+
+    Ptr<OranReporterLocation>          locationReporter = CreateObject<OranReporterLocation>();
+    Ptr<OranReporterAppLoss>           appLossReporter  = CreateObject<OranReporterAppLoss>();
+    Ptr<OranReporterLteUeCellInfo>     ueCellInfoRpt    = CreateObject<OranReporterLteUeCellInfo>();
+    Ptr<OranReporterLteUeRsrpRsrq>     rsrpRsrqReporter = CreateObject<OranReporterLteUeRsrpRsrq>();
+
+    locationReporter->SetAttribute("Terminator", PointerValue(lteUeTerminator));
+    appLossReporter->SetAttribute("Terminator", PointerValue(lteUeTerminator));
+    ueCellInfoRpt->SetAttribute("Terminator", PointerValue(lteUeTerminator));
+    rsrpRsrqReporter->SetAttribute("Terminator", PointerValue(lteUeTerminator));
+
+    // Hook app loss (if you kept those containers earlier)
+    remoteApps.Get(idx)->TraceConnectWithoutContext(
+        "Tx", MakeCallback(&ns3::OranReporterAppLoss::AddTx, appLossReporter));
+    ueApps.Get(idx)->TraceConnectWithoutContext(
+        "Rx", MakeCallback(&ns3::OranReporterAppLoss::AddRx, appLossReporter));
+
+    // Hook RSRP/RSRQ measurements from the UE PHY
+    for (uint32_t netDevIdx = 0; netDevIdx < ueNodes.Get(idx)->GetNDevices(); netDevIdx++)
+    {
+      Ptr<LteUeNetDevice> lteUeDevice =
+          ueNodes.Get(idx)->GetDevice(netDevIdx)->GetObject<LteUeNetDevice>();
+      if (lteUeDevice)
+      {
+        Ptr<LteUePhy> uePhy = lteUeDevice->GetPhy();
+        uePhy->TraceConnectWithoutContext(
+            "ReportUeMeasurements",
+            MakeCallback(&ns3::OranReporterLteUeRsrpRsrq::ReportRsrpRsrq, rsrpRsrqReporter));
+      }
+    }
+
+    lteUeTerminator->AddReporter(locationReporter);
+    lteUeTerminator->AddReporter(appLossReporter);
+    lteUeTerminator->AddReporter(ueCellInfoRpt);
+    lteUeTerminator->AddReporter(rsrpRsrqReporter);
+
+    lteUeTerminator->Attach(ueNodes.Get(idx));
+
+    // IMPORTANT: add to the UE container so our bulk activation works
+    e2NodeTerminatorsUes.Add(lteUeTerminator);
+  }
+
+  // Optional: DB logging for RIC query results
+  if (dbLog)
+  {
+    nearRtRic->Data()->TraceConnectWithoutContext("QueryRc", MakeCallback(&QueryRcSink));
+  }
+
+  // Activate in order: RIC -> eNB E2 nodes -> UE E2 nodes
+  Simulator::Schedule(Seconds(1.0),
+                      &OranHelper::ActivateAndStartNearRtRic,
+                      oranHelper, nearRtRic);
+
+  Simulator::Schedule(Seconds(1.5),
+                      &OranHelper::ActivateE2NodeTerminators,
+                      oranHelper, e2NodeTerminatorsEnbs);
+
+  Simulator::Schedule(Seconds(2.0),
+                      &OranHelper::ActivateE2NodeTerminators,
+                      oranHelper, e2NodeTerminatorsUes);
+  // --------------------- ORAN Models -- END ---------------------
+
 
   // --------------------- Handover tracing ---------------------
   Config::ConnectWithoutContext ("/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk",
diff --git a/model/oran-data-repository-sqlite.cc b/model/oran-data-repository-sqlite.cc
index 78bfdfe..2846fd6 100644
--- a/model/oran-data-repository-sqlite.cc
+++ b/model/oran-data-repository-sqlite.cc
@@ -36,6 +36,8 @@
 #include <ns3/simulator.h>
 #include <ns3/string.h>
 
+#include <cmath>
+
 namespace ns3
 {
 
@@ -384,6 +386,14 @@ OranDataRepositorySqlite::SaveLteUeRsrpRsrq(uint64_t e2NodeId,
                                             uint8_t componentCarrierId)
 {
     NS_LOG_FUNCTION(this << e2NodeId << t << +rnti << +cellId << rsrp << rsrq << isServing << +componentCarrierId);
+    
+    // Drop bad readings (recommended)
+    if (!std::isfinite(rsrp) || !std::isfinite(rsrq)) {
+      NS_LOG_WARN("Skipping RSRP/RSRQ report with non-finite value: "
+                << "RSRP=" << rsrp << " RSRQ=" << rsrq
+                << " (rnti=" << +rnti << " cellId=" << +cellId << ")");
+      return;
+    }
 
     if (m_active)
     {
diff --git a/model/oran-lm-lte-2-lte-energy-saving.cc b/model/oran-lm-lte-2-lte-energy-saving.cc
index 2930970..7759b07 100644
--- a/model/oran-lm-lte-2-lte-energy-saving.cc
+++ b/model/oran-lm-lte-2-lte-energy-saving.cc
@@ -2,8 +2,13 @@
 /**
  * \ingroup oran
  *
- * Implementation of the LTE UE energy‐saving logic module,
- * which directly tweaks eNB TxPower to steer energy‐efficiency.
+ * Energy-saving LM for LTE eNBs.
+ * Adjusts eNB TxPower to steer energy efficiency toward a target.
+ *
+ * Fixes over the original:
+ *  - Uses delta efficiency (Δbits / ΔJ) between invocations; no hard-coded initial energy.
+ *  - Emits at most one TxPower command per eNB per tick (no per-UE amplification).
+ *  - First invocation warms up state and sends no commands (avoids division-by-zero / jitters).
  */
 
 #include "oran-lm-lte-2-lte-energy-saving.h"
@@ -15,10 +20,12 @@
 #include <ns3/log.h>
 #include <ns3/oran-module.h>
 #include <ns3/simulator.h>
-#include <ns3/double.h>           // for DoubleValue, MakeDoubleAccessor, MakeDoubleChecker
-#include <ns3/uinteger.h>         // for UintegerValue
-#include <ns3/lte-enb-net-device.h>// for LteEnbNetDevice
-#include <ns3/lte-enb-phy.h>       // for LteEnbPhy
+#include <ns3/double.h>
+#include <ns3/uinteger.h>
+
+#include <unordered_map>
+#include <limits>
+#include <cmath>
 
 namespace ns3 {
 
@@ -26,96 +33,147 @@ NS_LOG_COMPONENT_DEFINE("OranLmLte2LteEnergySaving");
 NS_OBJECT_ENSURE_REGISTERED(OranLmLte2LteEnergySaving);
 
 TypeId
-OranLmLte2LteEnergySaving::GetTypeId(void)
+OranLmLte2LteEnergySaving::GetTypeId (void)
 {
   static TypeId tid = TypeId("ns3::OranLmLte2LteEnergySaving")
     .SetParent<OranLm>()
     .AddConstructor<OranLmLte2LteEnergySaving>()
     .AddAttribute("TargetEfficiency",
-                  "Desired energy‐efficiency (bits per joule)",
+                  "Desired energy efficiency (bits per Joule) measured over the last LM window.",
                   DoubleValue(1e6),
                   MakeDoubleAccessor(&OranLmLte2LteEnergySaving::m_targetEfficiency),
-                  MakeDoubleChecker<double>())
+                  MakeDoubleChecker<double>(0.0))
     .AddAttribute("StepSize",
-                  "Transmit power adjustment step (dB)",
+                  "Transmit-power adjustment step (dB) per LM invocation. Positive raises power, negative lowers.",
                   DoubleValue(1.0),
                   MakeDoubleAccessor(&OranLmLte2LteEnergySaving::m_stepSize),
-                  MakeDoubleChecker<double>());
+                  MakeDoubleChecker<double>(0.0));
   return tid;
 }
 
-OranLmLte2LteEnergySaving::OranLmLte2LteEnergySaving()
-  : OranLm()
+OranLmLte2LteEnergySaving::OranLmLte2LteEnergySaving ()
+  : OranLm ()
 {
   NS_LOG_FUNCTION(this);
   m_name = "OranLmLte2LteEnergySaving";
 }
 
-OranLmLte2LteEnergySaving::~OranLmLte2LteEnergySaving()
+OranLmLte2LteEnergySaving::~OranLmLte2LteEnergySaving ()
 {
   NS_LOG_FUNCTION(this);
 }
 
-std::vector<Ptr<OranCommand>>
-OranLmLte2LteEnergySaving::Run(void)
+/* ---------- Local LM state (per process) -------------------------
+ * We keep prior counters to compute deltas between invocations.
+ * Stored here to avoid changing the header/API.
+ */
+namespace {
+  // Total RX bits across all UEs on the last run
+  double g_prevTotalBits = std::numeric_limits<double>::quiet_NaN();
+
+  // Per-eNB remaining energy at the last run (J)
+  std::unordered_map<uint32_t, double> g_prevEnbRemainingJ;
+} // anonymous
+
+std::vector< Ptr<OranCommand> >
+OranLmLte2LteEnergySaving::Run (void)
 {
   NS_LOG_FUNCTION(this);
-  std::vector<Ptr<OranCommand>> commands; // we won't actually enqueue any OranCommands
 
-  NS_LOG_INFO("Energy‐Saving LM starting; target=" << m_targetEfficiency
-               << " step=" << m_stepSize);
+  std::vector< Ptr<OranCommand> > commands;
 
   if (!m_active)
-  {
-    NS_LOG_WARN("  → inactive, skipping");
-    return commands;
-  }
+    {
+      NS_LOG_WARN("Energy-Saving LM inactive; skipping.");
+      return commands;
+    }
   if (m_nearRtRic == nullptr)
-  {
-    NS_LOG_WARN("  → no RIC, skipping");
-    return commands;
-  }
+    {
+      NS_LOG_WARN("No Near-RT RIC; skipping.");
+      return commands;
+    }
 
-  Ptr<OranDataRepository> repo = m_nearRtRic->Data();
+  Ptr<OranDataRepository> repo = m_nearRtRic->Data ();
 
-  // For each UE, compute a delta and apply to all eNBs
+  // 1) Aggregate RX across all UEs (bits)
+  double totalBitsNow = 0.0;
   for (auto ueId : repo->GetLteUeE2NodeIds())
-  {
-    uint32_t rxBytes = repo->GetAppRx(ueId);
+    {
+      // repo->GetAppRx() returns bytes (as used in your original LM)
+      const uint64_t rxBytes = repo->GetAppRx(ueId);
+      totalBitsNow += static_cast<double>(rxBytes) * 8.0;
+    }
 
-    // Instead, emit one TxPower command per eNB:
-    for (auto enbId : repo->GetLteEnbE2NodeIds())
+  // 2) Warm-up on first invocation: capture baselines, emit no commands
+  const bool firstRun = !std::isfinite(g_prevTotalBits);
+  if (firstRun)
     {
-      double remainingEnergy = repo->GetLteEnergyRemaining(enbId);
-      double consumed = 100000 - remainingEnergy; // initial - remaining
-      double eff   = (rxBytes * 8) / consumed;
-      double delta = 0;
-      if      (eff < m_targetEfficiency)
-      {
-        delta =  m_stepSize;
-        NS_LOG_INFO("  UE " << ueId << ": eff = (" << rxBytes << " * 8 / " << consumed << ") = " << eff << " < target, ↑" << delta);
-      }
-      else if (eff > m_targetEfficiency)
-      {
-        delta = -m_stepSize;
-        NS_LOG_INFO("  UE " << ueId << ": eff=" << eff << " > target, ↓" << -delta);
-      }
-      else
-      {
-        NS_LOG_INFO("  UE " << ueId << ": eff=" << eff << " == target, no change");
-        continue;
-      }
-
-      Ptr<OranCommandLte2LteTxPower> cmd =
-      CreateObject<OranCommandLte2LteTxPower>();
+      g_prevTotalBits = totalBitsNow;
+      for (auto enbId : repo->GetLteEnbE2NodeIds())
+        {
+          g_prevEnbRemainingJ[enbId] = repo->GetLteEnergyRemaining(enbId);
+        }
+      NS_LOG_INFO("Energy-Saving LM warm-up; no commands this tick.");
+      return commands;
+    }
+
+  // 3) Compute Δbits since last run
+  double deltaBits = totalBitsNow - g_prevTotalBits;
+  g_prevTotalBits  = totalBitsNow;
+
+  // Guard tiny/negative deltas (e.g., clock skew or repo lag)
+  if (deltaBits < 0.0) deltaBits = 0.0;
+
+  // Small epsilon to avoid too-aggressive toggling when very close to target
+  const double eps = 1e-6;
+
+  // 4) For each eNB, compute ΔJ and decide a single ±StepSize command
+  for (auto enbId : repo->GetLteEnbE2NodeIds())
+    {
+      const double remNow = repo->GetLteEnergyRemaining(enbId);
+      double &remPrevRef  = g_prevEnbRemainingJ[enbId]; // creates if missing
+      double deltaJ       = remPrevRef - remNow;        // energy consumed in this LM window
+      remPrevRef          = remNow;                     // update baseline
+
+      // Guards
+      if (deltaJ <= 0.0 || deltaBits <= 0.0)
+        {
+          NS_LOG_INFO("eNB " << enbId
+                      << ": ΔJ=" << deltaJ << " J, Δbits=" << deltaBits
+                      << " → no command (insufficient delta).");
+          continue;
+        }
+
+      const double eff = deltaBits / deltaJ; // bits per Joule in last window
+
+      double deltaDb = 0.0;
+      if      (eff < m_targetEfficiency - eps) deltaDb =  m_stepSize; // below target → add power
+      else if (eff > m_targetEfficiency + eps) deltaDb = -m_stepSize; // above target → reduce power
+      else                                     deltaDb =  0.0;         // within dead-band
+
+      if (std::abs(deltaDb) < eps)
+        {
+          NS_LOG_INFO("eNB " << enbId << ": eff=" << eff
+                        << " ~ target=" << m_targetEfficiency
+                        << " (dead-band), no change.");
+          continue;
+        }
+
+      // Emit exactly one command per eNB
+      Ptr<OranCommandLte2LteTxPower> cmd = CreateObject<OranCommandLte2LteTxPower>();
       cmd->SetAttribute("TargetE2NodeId", UintegerValue(enbId));
-      cmd->SetAttribute("PowerDeltaDb",   DoubleValue(delta));
+      cmd->SetAttribute("PowerDeltaDb",   DoubleValue(deltaDb));
 
-      // Log & queue it
       repo->LogCommandLm(m_name, cmd);
       commands.push_back(cmd);
+
+      NS_LOG_INFO("eNB " << enbId
+                  << ": Δbits=" << deltaBits
+                  << " ΔJ=" << deltaJ
+                  << " eff=" << eff
+                  << " target=" << m_targetEfficiency
+                  << " → cmd ΔTx=" << deltaDb << " dB");
     }
-  }
 
   return commands;
 }
diff --git a/model/oran-lm-lte-2-lte-rsrp-handover.cc b/model/oran-lm-lte-2-lte-rsrp-handover.cc
index 9dd3447..204d668 100644
--- a/model/oran-lm-lte-2-lte-rsrp-handover.cc
+++ b/model/oran-lm-lte-2-lte-rsrp-handover.cc
@@ -1,32 +1,12 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /**
- * NIST-developed software is provided by NIST as a public service. You may
- * use, copy and distribute copies of the software in any medium, provided that
- * you keep intact this entire notice. You may improve, modify and create
- * derivative works of the software or any portion of the software, and you may
- * copy and distribute such modifications or works. Modified works should carry
- * a notice stating that you changed the software and should note the date and
- * nature of any such change. Please explicitly acknowledge the National
- * Institute of Standards and Technology as the source of the software.
+ * RSRP-driven LTE→LTE handover LM with robust guards.
  *
- * NIST-developed software is expressly provided "AS IS." NIST MAKES NO
- * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF
- * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST
- * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE
- * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST
- * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE
- * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE
- * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.
- *
- * You are solely responsible for determining the appropriateness of using and
- * distributing the software and you assume all risks associated with its use,
- * including but not limited to the risks and costs of program errors,
- * compliance with applicable laws, damage to or loss of data, programs or
- * equipment, and the unavailability or interruption of operation. This
- * software is not intended to be used in any situation where a failure could
- * cause risk of injury or damage to property. The software developed by NIST
- * employees is not subject to copyright protection within the United States.
+ * Fixes:
+ *  - Guard against missing serving eNB mapping (no uninitialized oldCellNodeId).
+ *  - Skip if RSRP measurements are absent or non-finite.
+ *  - Add per-UE handover hold-off to avoid rapid re-triggers during state churn.
+ *  - Add small hysteresis & per-UE hold-off to avoid rapid re-triggers.
  */
 
 #include "oran-lm-lte-2-lte-rsrp-handover.h"
@@ -40,220 +20,232 @@
 #include <ns3/uinteger.h>
 
 #include <cfloat>
+#include <cmath>
+#include <unordered_map>
 
 namespace ns3
 {
 
 NS_LOG_COMPONENT_DEFINE("OranLmLte2LteRsrpHandover");
-
 NS_OBJECT_ENSURE_REGISTERED(OranLmLte2LteRsrpHandover);
 
+/* ---------- Simple per-UE debounce (no header change) ---------- */
+namespace {
+  constexpr double kHoHoldoffSec = 1.5;   // seconds between HOs per UE
+  constexpr double kRsrpHystDb   = 1.0;   // require +1 dB better to trigger
+  std::unordered_map<uint64_t,double> g_lastHoTime; // ueId -> last HO sim time (s)
+}
+
 TypeId
 OranLmLte2LteRsrpHandover::GetTypeId(void)
 {
-    static TypeId tid = TypeId("ns3::OranLmLte2LteRsrpHandover")
-                            .SetParent<OranLm>()
-                            .AddConstructor<OranLmLte2LteRsrpHandover>();
-
-    return tid;
+  static TypeId tid = TypeId("ns3::OranLmLte2LteRsrpHandover")
+                        .SetParent<OranLm>()
+                        .AddConstructor<OranLmLte2LteRsrpHandover>();
+  return tid;
 }
 
 OranLmLte2LteRsrpHandover::OranLmLte2LteRsrpHandover(void)
-    : OranLm()
+  : OranLm()
 {
-    NS_LOG_FUNCTION(this);
-
-    m_name = "OranLmLte2LteRsrpHandover";
+  m_name = "OranLmLte2LteRsrpHandover";
 }
 
-OranLmLte2LteRsrpHandover::~OranLmLte2LteRsrpHandover(void)
-{
-    NS_LOG_FUNCTION(this);
-}
+OranLmLte2LteRsrpHandover::~OranLmLte2LteRsrpHandover(void) = default;
 
 std::vector<Ptr<OranCommand>>
 OranLmLte2LteRsrpHandover::Run(void)
 {
-    NS_LOG_FUNCTION(this);
+  std::vector<Ptr<OranCommand>> commands;
 
-    std::vector<Ptr<OranCommand>> commands;
+  if (!m_active)
+  {
+    NS_LOG_INFO("RSRP LM inactive; skipping.");
+    return commands;
+  }
 
-    if (m_active)
-    {
-        NS_ABORT_MSG_IF(m_nearRtRic == nullptr,
-                        "Attempting to run LM (" + m_name + ") with NULL Near-RT RIC");
+  NS_ABORT_MSG_IF(m_nearRtRic == nullptr,
+                  "Attempting to run LM (" + m_name + ") with NULL Near-RT RIC");
 
-        Ptr<OranDataRepository> data = m_nearRtRic->Data();
-        std::vector<UeInfo> ueInfos = GetUeInfos(data);
-        std::vector<EnbInfo> enbInfos = GetEnbInfos(data);
-        commands = GetHandoverCommands(data, ueInfos, enbInfos);
-    }
+  Ptr<OranDataRepository> data = m_nearRtRic->Data();
 
-    // Return the commands.
-    return commands;
+  auto ueInfos  = GetUeInfos(data);
+  auto enbInfos = GetEnbInfos(data);
+
+  commands = GetHandoverCommands(data, ueInfos, enbInfos);
+  return commands;
 }
 
 std::vector<OranLmLte2LteRsrpHandover::UeInfo>
 OranLmLte2LteRsrpHandover::GetUeInfos(Ptr<OranDataRepository> data) const
 {
-    NS_LOG_FUNCTION(this << data);
+  std::vector<UeInfo> ueInfos;
+  for (auto ueId : data->GetLteUeE2NodeIds())
+  {
+    UeInfo ueInfo;
+    ueInfo.nodeId = ueId;
+
+    bool found;
+    std::tie(found, ueInfo.cellId, ueInfo.rnti) = data->GetLteUeCellInfo(ueInfo.nodeId);
+    if (!found)
+    {
+      NS_LOG_INFO("No UE cell info for E2 UE " << ueInfo.nodeId);
+      continue;
+    }
 
-    std::vector<UeInfo> ueInfos;
-    for (auto ueId : data->GetLteUeE2NodeIds())
+    auto nodePositions = data->GetNodePositions(ueInfo.nodeId, Seconds(0), Simulator::Now());
+    if (nodePositions.empty())
     {
-        UeInfo ueInfo;
-        ueInfo.nodeId = ueId;
-        // Get the current cell ID and RNTI of the UE and record it.
-        bool found;
-        std::tie(found, ueInfo.cellId, ueInfo.rnti) = data->GetLteUeCellInfo(ueInfo.nodeId);
-        if (found)
-        {
-            // Get the latest location of the UE.
-            std::map<Time, Vector> nodePositions =
-                data->GetNodePositions(ueInfo.nodeId, Seconds(0), Simulator::Now());
-
-            if (!nodePositions.empty())
-            {
-                // We found both the cell and location informtaion for this UE
-                // so record it for a later analysis.
-                ueInfo.position = nodePositions.rbegin()->second;
-                ueInfos.push_back(ueInfo);
-            }
-            else
-            {
-                NS_LOG_INFO("Could not find LTE UE location for E2 Node ID = " << ueInfo.nodeId);
-            }
-        }
-        else
-        {
-            NS_LOG_INFO("Could not find LTE UE cell info for E2 Node ID = " << ueInfo.nodeId);
-        }
+      NS_LOG_INFO("No UE position for E2 UE " << ueInfo.nodeId);
+      continue;
     }
-    return ueInfos;
+
+    ueInfo.position = nodePositions.rbegin()->second;
+    ueInfos.push_back(ueInfo);
+  }
+  return ueInfos;
 }
 
 std::vector<OranLmLte2LteRsrpHandover::EnbInfo>
 OranLmLte2LteRsrpHandover::GetEnbInfos(Ptr<OranDataRepository> data) const
 {
-    NS_LOG_FUNCTION(this << data);
+  std::vector<EnbInfo> enbInfos;
+  for (auto enbId : data->GetLteEnbE2NodeIds())
+  {
+    EnbInfo enbInfo;
+    enbInfo.nodeId = enbId;
+
+    bool found;
+    std::tie(found, enbInfo.cellId) = data->GetLteEnbCellInfo(enbInfo.nodeId);
+    if (!found)
+    {
+      NS_LOG_INFO("No eNB cell info for E2 eNB " << enbInfo.nodeId);
+      continue;
+    }
 
-    std::vector<EnbInfo> enbInfos;
-    for (auto enbId : data->GetLteEnbE2NodeIds())
+    auto nodePositions = data->GetNodePositions(enbInfo.nodeId, Seconds(0), Simulator::Now());
+    if (nodePositions.empty())
     {
-        EnbInfo enbInfo;
-        enbInfo.nodeId = enbId;
-        // Get the cell ID of this eNB and record it.
-        bool found;
-        std::tie(found, enbInfo.cellId) = data->GetLteEnbCellInfo(enbInfo.nodeId);
-        if (found)
-        {
-            // Get all known locations of the eNB.
-            std::map<Time, Vector> nodePositions =
-                data->GetNodePositions(enbInfo.nodeId, Seconds(0), Simulator::Now());
-
-            if (!nodePositions.empty())
-            {
-                // We found both the cell and location information for this
-                // eNB so record it for a later analysis.
-                enbInfo.position = nodePositions.rbegin()->second;
-                enbInfos.push_back(enbInfo);
-            }
-            else
-            {
-                NS_LOG_INFO("Could not find LTE eNB location for E2 Node ID = " << enbInfo.nodeId);
-            }
-        }
-        else
-        {
-            NS_LOG_INFO("Could not find LTE eNB cell info for E2 Node ID = " << enbInfo.nodeId);
-        }
+      NS_LOG_INFO("No eNB position for E2 eNB " << enbInfo.nodeId);
+      continue;
     }
-    return enbInfos;
+
+    enbInfo.position = nodePositions.rbegin()->second;
+    enbInfos.push_back(enbInfo);
+  }
+  return enbInfos;
 }
 
 std::vector<Ptr<OranCommand>>
 OranLmLte2LteRsrpHandover::GetHandoverCommands(
     Ptr<OranDataRepository> data,
-    std::vector<OranLmLte2LteRsrpHandover::UeInfo> ueInfos,
-    std::vector<OranLmLte2LteRsrpHandover::EnbInfo> enbInfos) const
+    std::vector<UeInfo> ueInfos,
+    std::vector<EnbInfo> enbInfos) const
 {
-    NS_LOG_FUNCTION(this << data);
+  std::vector<Ptr<OranCommand>> commands;
+
+  // Map cellId -> eNB nodeId (serving lookup)
+  std::unordered_map<uint16_t, uint64_t> cellIdToNodeId;
+  cellIdToNodeId.reserve(enbInfos.size());
+  for (const auto& e : enbInfos)
+  {
+    cellIdToNodeId[e.cellId] = e.nodeId;
+  }
+
+  const double now = Simulator::Now().GetSeconds();
+
+  for (const auto& ueInfo : ueInfos)
+  {
+    // Debounce repeated HOs per UE
+    auto itLast = g_lastHoTime.find(ueInfo.nodeId);
+    if (itLast != g_lastHoTime.end() && (now - itLast->second) < kHoHoldoffSec)
+    {
+      NS_LOG_INFO("UE " << ueInfo.nodeId << ": within HO hold-off; skipping.");
+      continue;
+    }
 
-    std::vector<Ptr<OranCommand>> commands;
+    // Must have a valid RNTI
+    if (ueInfo.rnti == 0)
+    {
+      NS_LOG_WARN("UE " << ueInfo.nodeId << ": RNTI=0; suppressing HO.");
+      continue;
+    }
 
-    // Compare the location of each active eNB with the location of each active
-    // UE and see if that UE is currently being served by the closet cell. If
-    // there is a closer eNB to the UE then the currently serving cell then
-    // issue a handover command.
-    for (auto ueInfo : ueInfos)
+    // Pull latest RSRP/RSRQ
+    auto meas = data->GetLteUeRsrpRsrq(ueInfo.nodeId);
+    if (meas.empty())
     {
-        double max = -DBL_MAX;               // The maximum RSRP recorded.
-        uint64_t oldCellNodeId;             // The ID of the cell currently serving the UE.
-        uint16_t newCellId = ueInfo.cellId; // The ID of the closest cell.
-        auto rsrpMeasurements = data->GetLteUeRsrpRsrq(ueInfo.nodeId);
-        for (auto rsrpMeasurement : rsrpMeasurements)
-        {
-            uint16_t rnti;
-            uint16_t cellId;
-            double rsrp;
-            double rsrq;
-            bool isServingCell;
-            uint16_t componentCarrierId;
-            std::tie(rnti, cellId, rsrp, rsrq, isServingCell, componentCarrierId) = rsrpMeasurement;
-            LogLogicToRepository("RSRP from UE with RNTI " + std::to_string(rnti) +
-                                 " in CellID " + std::to_string(ueInfo.cellId) +
-                                 " to eNB with CellID " + std::to_string(cellId) + " is " +
-                                 std::to_string(rsrp));
-
-            // Check if the RSRP is greater than the current maximum
-            if (rsrp > max)
-            {
-                // Record the new maximum
-                max = rsrp;
-                // Record the ID of the cell that produced the new maximum.
-                newCellId = cellId;
-
-                LogLogicToRepository("RSRP to eNB with CellID " +
-                                     std::to_string(cellId) + " is largest so far");
-            }
-        }
-
-        for (const auto& enbInfo : enbInfos)
-        {
-            // Check if this cell is the currently serving this UE.
-            if (ueInfo.cellId == enbInfo.cellId)
-            {
-                // It is, so indicate record the ID of the cell that is
-                // currently serving the UE.
-                oldCellNodeId = enbInfo.nodeId;
-            }
-        }
-
-        // Check if the ID of the closest cell is different from ID of the cell
-        // that is currently serving the UE
-        if (newCellId != ueInfo.cellId)
-        {
-            // It is, so issue a handover command.
-            Ptr<OranCommandLte2LteHandover> handoverCommand =
-                CreateObject<OranCommandLte2LteHandover>();
-            // Send the command to the cell currently serving the UE.
-            handoverCommand->SetAttribute("TargetE2NodeId", UintegerValue(oldCellNodeId));
-            // Use the RNTI that the current cell is using to identify the UE.
-            handoverCommand->SetAttribute("TargetRnti", UintegerValue(ueInfo.rnti));
-            // Give the current cell the ID of the new cell to handover to.
-            handoverCommand->SetAttribute("TargetCellId", UintegerValue(newCellId));
-            // Log the command to the storage
-            data->LogCommandLm(m_name, handoverCommand);
-            // Add the command to send.
-            commands.push_back(handoverCommand);
-
-            LogLogicToRepository("eNB (CellID " + std::to_string(newCellId) + ")" +
-                                 " is different than the currently attached eNB" + " (CellID " +
-                                 std::to_string(ueInfo.cellId) + ")." +
-                                 " Issuing handover command.");
-        }
+      NS_LOG_INFO("UE " << ueInfo.nodeId << ": no RSRP/RSRQ measurements; skipping.");
+      continue;
     }
-    return commands;
+
+    // Track best & current-cell RSRP
+    double   bestRsrp = -DBL_MAX;
+    uint16_t bestCell = ueInfo.cellId;
+    double   currRsrp = -DBL_MAX;
+
+    for (const auto& m : meas)
+    {
+      uint16_t rnti, cellId; double rsrp, rsrq; bool serving; uint8_t ccid;
+      std::tie(rnti, cellId, rsrp, rsrq, serving, ccid) = m;
+
+      if (!std::isfinite(rsrp)) continue;     // guard against NaN/Inf
+
+      if (cellId == ueInfo.cellId && rsrp > currRsrp)
+        currRsrp = rsrp;
+
+      if (rsrp > bestRsrp)
+      {
+        bestRsrp = rsrp;
+        bestCell = cellId;
+      }
+    }
+
+    // If we never saw a finite current-cell RSRP, be conservative
+    if (!std::isfinite(currRsrp))
+    {
+      NS_LOG_WARN("UE " << ueInfo.nodeId << ": no finite current-cell RSRP; skipping.");
+      continue;
+    }
+
+    // If best is current (or not better than hysteresis), skip
+    if (bestCell == ueInfo.cellId || (bestRsrp - currRsrp) < kRsrpHystDb)
+    {
+      continue;
+    }
+
+    // Resolve serving eNB nodeId for the UE's current cell
+    auto itNode = cellIdToNodeId.find(ueInfo.cellId);
+    if (itNode == cellIdToNodeId.end())
+    {
+      NS_LOG_WARN("UE " << ueInfo.nodeId
+                  << ": serving cellId " << ueInfo.cellId
+                  << " not in enbInfos; suppressing HO to avoid null deref.");
+      continue; // critical guard
+    }
+    const uint64_t oldCellNodeId = itNode->second;
+
+    // Build and log command
+    Ptr<OranCommandLte2LteHandover> cmd = CreateObject<OranCommandLte2LteHandover>();
+    cmd->SetAttribute("TargetE2NodeId", UintegerValue(oldCellNodeId)); // send to serving eNB
+    cmd->SetAttribute("TargetRnti",     UintegerValue(ueInfo.rnti));
+    cmd->SetAttribute("TargetCellId",   UintegerValue(bestCell));
+
+    data->LogCommandLm(m_name, cmd);
+    commands.push_back(cmd);
+
+    g_lastHoTime[ueInfo.nodeId] = now;
+
+    NS_LOG_INFO("UE " << ueInfo.nodeId << ": HO requested "
+                 << ueInfo.cellId << " → " << bestCell
+                 << " (RSRP " << currRsrp << "→" << bestRsrp
+                 << ", via eNB nodeId " << oldCellNodeId
+                 << ", RNTI " << ueInfo.rnti << ")");
+  }
+
+  return commands;
 }
 
 } // namespace ns3
+
+
diff --git a/model/oran-report-lte-ue-rsrp-rsrq.cc b/model/oran-report-lte-ue-rsrp-rsrq.cc
index a75be59..f8efd17 100644
--- a/model/oran-report-lte-ue-rsrp-rsrq.cc
+++ b/model/oran-report-lte-ue-rsrp-rsrq.cc
@@ -22,25 +22,24 @@
  * You are solely responsible for determining the appropriateness of using and
  * distributing the software and you assume all risks associated with its use,
  * including but not limited to the risks and costs of program errors,
- * compliance with applicable laws, damage to or rsrp of data, programs or
+ * compliance with applicable laws, damage to or loss of data, programs or
  * equipment, and the unavailability or interruption of operation. This
  * software is not intended to be used in any situation where a failure could
  * cause risk of injury or damage to property. The software developed by NIST
  * employees is not subject to copyright protection within the United States.
  */
 
-#include "oran-report-lte-ue-rsrp-rsrq.h"
 
-#include "oran-report.h"
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
+#include "oran-report-lte-ue-rsrp-rsrq.h"
 
-#include <ns3/abort.h>
 #include <ns3/boolean.h>
 #include <ns3/double.h>
 #include <ns3/log.h>
 #include <ns3/uinteger.h>
+#include <sstream>
 
-namespace ns3
-{
+namespace ns3 {
 
 NS_LOG_COMPONENT_DEFINE("OranReportLteUeRsrpRsrq");
 NS_OBJECT_ENSURE_REGISTERED(OranReportLteUeRsrpRsrq);
@@ -48,121 +47,64 @@ NS_OBJECT_ENSURE_REGISTERED(OranReportLteUeRsrpRsrq);
 TypeId
 OranReportLteUeRsrpRsrq::GetTypeId()
 {
-    static TypeId tid = TypeId("ns3::OranReportLteUeRsrpRsrq")
-                            .SetParent<OranReport>()
-                            .AddConstructor<OranReportLteUeRsrpRsrq>()
-                            .AddAttribute("Rnti",
-                                          "The RNTI.",
-                                          UintegerValue(),
-                                          MakeUintegerAccessor(&OranReportLteUeRsrpRsrq::m_rnti),
-                                          MakeUintegerChecker<uint16_t>())
-                            .AddAttribute("CellId",
-                                          "The cell ID.",
-                                          UintegerValue(),
-                                          MakeUintegerAccessor(&OranReportLteUeRsrpRsrq::m_cellId),
-                                          MakeUintegerChecker<uint16_t>())
-                            .AddAttribute("Rsrp",
-                                          "The RSRP.",
-                                          DoubleValue(),
-                                          MakeDoubleAccessor(&OranReportLteUeRsrpRsrq::m_rsrp),
-                                          MakeDoubleChecker<double>())
-                            .AddAttribute("Rsrq",
-                                          "The RSRQ.",
-                                          DoubleValue(),
-                                          MakeDoubleAccessor(&OranReportLteUeRsrpRsrq::m_rsrq),
-                                          MakeDoubleChecker<double>())
-                            .AddAttribute("IsServingCell",
-                                          "The flag that indicates if this for the serving cell.",
-                                          BooleanValue(),
-                                          MakeBooleanAccessor(&OranReportLteUeRsrpRsrq::m_isServingCell),
-                                          MakeBooleanChecker())
-                            .AddAttribute("ComponentCarrierId",
-                                          "The component carrier ID.",
-                                          UintegerValue(),
-                                          MakeUintegerAccessor(&OranReportLteUeRsrpRsrq::m_componentCarrierId),
-                                          MakeUintegerChecker<uint16_t>());
-
-    return tid;
-}
-
-OranReportLteUeRsrpRsrq::OranReportLteUeRsrpRsrq()
-{
-    NS_LOG_FUNCTION(this);
+  static TypeId tid = TypeId("ns3::OranReportLteUeRsrpRsrq")
+    .SetParent<OranReport>()
+    .AddConstructor<OranReportLteUeRsrpRsrq>()
+    // Attributes retained for inspection/config; not used at runtime anymore.
+    .AddAttribute("Rnti",  "The RNTI.",
+                  UintegerValue(0),
+                  MakeUintegerAccessor(&OranReportLteUeRsrpRsrq::m_rnti),
+                  MakeUintegerChecker<uint16_t>())
+    .AddAttribute("CellId","The cell ID.",
+                  UintegerValue(0),
+                  MakeUintegerAccessor(&OranReportLteUeRsrpRsrq::m_cellId),
+                  MakeUintegerChecker<uint16_t>())
+    .AddAttribute("Rsrp",  "The RSRP.",
+                  DoubleValue(0.0),
+                  MakeDoubleAccessor(&OranReportLteUeRsrpRsrq::m_rsrp),
+                  MakeDoubleChecker<double>())
+    .AddAttribute("Rsrq",  "The RSRQ.",
+                  DoubleValue(0.0),
+                  MakeDoubleAccessor(&OranReportLteUeRsrpRsrq::m_rsrq),
+                  MakeDoubleChecker<double>())
+    .AddAttribute("IsServingCell", "Is serving cell?",
+                  BooleanValue(false),
+                  MakeBooleanAccessor(&OranReportLteUeRsrpRsrq::m_isServingCell),
+                  MakeBooleanChecker())
+    .AddAttribute("ComponentCarrierId", "Component carrier ID.",
+                  UintegerValue(0),
+                  MakeUintegerAccessor(&OranReportLteUeRsrpRsrq::m_componentCarrierId),
+                  MakeUintegerChecker<uint16_t>());
+  return tid;
 }
 
-OranReportLteUeRsrpRsrq::~OranReportLteUeRsrpRsrq()
-{
-    NS_LOG_FUNCTION(this);
-}
+OranReportLteUeRsrpRsrq::OranReportLteUeRsrpRsrq() { NS_LOG_FUNCTION(this); }
+OranReportLteUeRsrpRsrq::~OranReportLteUeRsrpRsrq() { NS_LOG_FUNCTION(this); }
 
 std::string
 OranReportLteUeRsrpRsrq::ToString() const
 {
-    NS_LOG_FUNCTION(this);
-
-    std::stringstream ss;
-    Time time = GetTime();
-
-    ss << "OranReportLteUeRsrpRsrq("
-       << "E2NodeId=" << GetReporterE2NodeId()
-       << ";Time=" << time.As(Time::S)
-       << ";RNTI=" << +m_rnti
-       << ";Cell ID=" << +m_cellId
-       << ";RSRP=" << m_rsrp
-       << ";RSRQ=" << m_rsrq
-       << ";Is Serving Cell=" << m_isServingCell
-       << ";Component Carrier ID=" << +m_componentCarrierId
-       << ")";
-
-    return ss.str();
+  std::stringstream ss;
+  Time time = GetTime();
+  ss << "OranReportLteUeRsrpRsrq("
+     << "E2NodeId=" << GetReporterE2NodeId()
+     << ";Time=" << time.As(Time::S)
+     << ";RNTI=" << +m_rnti
+     << ";CellID=" << +m_cellId
+     << ";RSRP=" << m_rsrp
+     << ";RSRQ=" << m_rsrq
+     << ";IsServing=" << m_isServingCell
+     << ";CCID=" << +m_componentCarrierId
+     << ")";
+  return ss.str();
 }
 
-uint16_t
-OranReportLteUeRsrpRsrq::GetRnti() const
-{
-  NS_LOG_FUNCTION(this);
-
-  return m_rnti;
-}
-
-uint16_t
-OranReportLteUeRsrpRsrq::GetCellId() const
-{
-  NS_LOG_FUNCTION(this);
-
-  return m_cellId;
-}
-
-double
-OranReportLteUeRsrpRsrq::GetRsrp() const
-{
-    NS_LOG_FUNCTION(this);
-
-    return m_rsrp;
-}
-
-double
-OranReportLteUeRsrpRsrq::GetRsrq() const
-{
-    NS_LOG_FUNCTION(this);
-
-    return m_rsrp;
-}
-
-bool
-OranReportLteUeRsrpRsrq::GetIsServingCell() const
-{
-  NS_LOG_FUNCTION(this);
-
-  return m_isServingCell;
-}
-
-uint16_t
-OranReportLteUeRsrpRsrq::GetComponentCarrierId() const
-{
-  NS_LOG_FUNCTION(this);
-
-  return m_componentCarrierId;
-}
+uint16_t OranReportLteUeRsrpRsrq::GetRnti() const { return m_rnti; }
+uint16_t OranReportLteUeRsrpRsrq::GetCellId() const { return m_cellId; }
+double   OranReportLteUeRsrpRsrq::GetRsrp()  const { return m_rsrp; }
+double   OranReportLteUeRsrpRsrq::GetRsrq()  const { return m_rsrq; } // <-- fixed
+bool     OranReportLteUeRsrpRsrq::GetIsServingCell() const { return m_isServingCell; }
+uint16_t OranReportLteUeRsrpRsrq::GetComponentCarrierId() const { return m_componentCarrierId; }
 
 } // namespace ns3
+
diff --git a/model/oran-report-lte-ue-rsrp-rsrq.h b/model/oran-report-lte-ue-rsrp-rsrq.h
index 68fb387..e49ec1d 100644
--- a/model/oran-report-lte-ue-rsrp-rsrq.h
+++ b/model/oran-report-lte-ue-rsrp-rsrq.h
@@ -29,108 +29,53 @@
  * employees is not subject to copyright protection within the United States.
  */
 
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 #ifndef ORAN_REPORT_LTE_UE_RSRP_RSRQ
 #define ORAN_REPORT_LTE_UE_RSRP_RSRQ
 
 #include "oran-report.h"
-
 #include <string>
 
-namespace ns3
-{
+namespace ns3 {
 
 /**
  * \ingroup oran
- *
- * Report with the application packet loss of a node at a given time.
+ * UE RSRP/RSRQ report.
  */
 class OranReportLteUeRsrpRsrq : public OranReport
 {
-  public:
-    /**
-     * Get the TypeId of the OranReportLteUeRsrpRsrq class.
-     *
-     * \return The TypeId.
-     */
-    static TypeId GetTypeId();
-    /**
-     * Constructor of the OranReportLteUeRsrpRsrq class.
-     */
-    OranReportLteUeRsrpRsrq();
-    /**
-     * Destructor of the OranReportLteUeRsrpRsrq class.
-     */
-    ~OranReportLteUeRsrpRsrq() override;
-    /**
-     * Get a string representation of this Report
-     *
-     * \return A string representation of this Report.
-     */
-    std::string ToString() const override;
-    /**
-     * Gets the RNTI.
-     *
-     * \return The RNTI.
-     */
-    uint16_t GetRnti() const;
-    /**
-     * Gets the cell ID.
-     *
-     * \return The cell ID.
-     */
-    uint16_t GetCellId() const;
-    /**
-     * Gets the reported RSRP.
-     *
-     * \return The reported RSRP.
-     */
-    double GetRsrp() const;
-    /**
-     * Gets the reported RSRQ.
-     *
-     * \return The reported RSRQ.
-     */
-    double GetRsrq() const;
-    /**
-     * Gets the flag that indicates if this is for the serving cell.
-     *
-     * \return The flag.
-     */
-    bool GetIsServingCell() const;
-    /**
-     * Gets the component carrier ID.
-     *
-     * \return The component carrier ID.
-     */
-    uint16_t GetComponentCarrierId() const;
+public:
+  static TypeId GetTypeId();
+
+  OranReportLteUeRsrpRsrq();
+  ~OranReportLteUeRsrpRsrq() override;
+
+  std::string ToString() const override;
+
+  // Getters
+  uint16_t GetRnti() const;
+  uint16_t GetCellId() const;
+  double   GetRsrp()  const;
+  double   GetRsrq()  const;   // <-- returns m_rsrq (not m_rsrp)
+  bool     GetIsServingCell() const;
+  uint16_t GetComponentCarrierId() const;
 
-  private:
-    /**
-     * The RNTI.
-     */
-    uint16_t m_rnti;
-    /**
-     * The cell ID.
-     */
-    uint16_t m_cellId;
-    /**
-     * The RSRP.
-     */
-    double m_rsrp;
-    /**
-     * The RSRQ.
-     */
-    double m_rsrq;
-    /**
-     * A flag that indicates if the report is for the serving cell.
-     */
-    bool m_isServingCell;
-    /**
-     * The component carrier ID.
-     */
-    uint16_t m_componentCarrierId;
+  // Typed setters (use these instead of SetAttribute)
+  void SetRnti(uint16_t v)               { m_rnti = v; }
+  void SetCellId(uint16_t v)             { m_cellId = v; }
+  void SetRsrp(double v)                 { m_rsrp = v; }
+  void SetRsrq(double v)                 { m_rsrq = v; }
+  void SetIsServingCell(bool v)          { m_isServingCell = v; }
+  void SetComponentCarrierId(uint16_t v) { m_componentCarrierId = v; }
 
-}; // class OranReportLteUeRsrpRsrq
+private:
+  uint16_t m_rnti{0};
+  uint16_t m_cellId{0};
+  double   m_rsrp{0.0};
+  double   m_rsrq{0.0};
+  bool     m_isServingCell{false};
+  uint16_t m_componentCarrierId{0};
+};
 
 } // namespace ns3
 
diff --git a/model/oran-reporter-lte-ue-rsrp-rsrq.cc b/model/oran-reporter-lte-ue-rsrp-rsrq.cc
index 98add32..f079eb4 100644
--- a/model/oran-reporter-lte-ue-rsrp-rsrq.cc
+++ b/model/oran-reporter-lte-ue-rsrp-rsrq.cc
@@ -29,18 +29,16 @@
  * employees is not subject to copyright protection within the United States.
  */
 
-#include "oran-reporter-lte-ue-rsrp-rsrq.h"
+/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 
+#include "oran-reporter-lte-ue-rsrp-rsrq.h"
 #include "oran-report-lte-ue-rsrp-rsrq.h"
 
 #include <ns3/abort.h>
-#include <ns3/address.h>
-#include <ns3/boolean.h>
-#include <ns3/double.h>
 #include <ns3/log.h>
-#include <ns3/packet.h>
-#include <ns3/simulator.h>
-#include <ns3/uinteger.h>
+#include <ns3/simulator.h>     
+#include <ns3/uinteger.h>   
+
 
 namespace ns3
 {
@@ -51,73 +49,68 @@ NS_OBJECT_ENSURE_REGISTERED(OranReporterLteUeRsrpRsrq);
 TypeId
 OranReporterLteUeRsrpRsrq::GetTypeId()
 {
-    static TypeId tid = TypeId("ns3::OranReporterLteUeRsrpRsrq")
-                            .SetParent<OranReporter>()
-                            .AddConstructor<OranReporterLteUeRsrpRsrq>();
-
-    return tid;
+  static TypeId tid = TypeId("ns3::OranReporterLteUeRsrpRsrq")
+                        .SetParent<OranReporter>()
+                        .AddConstructor<OranReporterLteUeRsrpRsrq>();
+  return tid;
 }
 
 OranReporterLteUeRsrpRsrq::OranReporterLteUeRsrpRsrq()
 {
-    NS_LOG_FUNCTION(this);
+  NS_LOG_FUNCTION(this);
 }
 
 OranReporterLteUeRsrpRsrq::~OranReporterLteUeRsrpRsrq()
 {
-    NS_LOG_FUNCTION(this);
+  NS_LOG_FUNCTION(this);
 }
 
 void
 OranReporterLteUeRsrpRsrq::ReportRsrpRsrq(uint16_t rnti,
-                        uint16_t cellId,
-                        double rsrp,
-                        double rsrq,
-                        bool isServingCell,
-                        uint8_t componentCarrierId)
+                                          uint16_t cellId,
+                                          double rsrp,
+                                          double rsrq,
+                                          bool isServingCell,
+                                          uint8_t componentCarrierId)
 {
-    NS_LOG_FUNCTION(this
-                    << +rnti
-                    << +cellId
-                    << rsrp
-                    << rsrq
-                    << isServingCell
-                    << componentCarrierId);
-
-    if (m_active)
-    {
-        NS_ABORT_MSG_IF(m_terminator == nullptr,
-                        "Attempting to generate reports in reporter with NULL E2 Terminator");
-
-        Ptr<OranReportLteUeRsrpRsrq> report = CreateObject<OranReportLteUeRsrpRsrq>();
-        report->SetAttribute("ReporterE2NodeId", UintegerValue(m_terminator->GetE2NodeId()));
-        report->SetAttribute("Time", TimeValue(Simulator::Now()));
-        report->SetAttribute("Rnti", UintegerValue(rnti));
-        report->SetAttribute("CellId", UintegerValue(cellId));
-        report->SetAttribute("Rsrp", DoubleValue(rsrp));
-        report->SetAttribute("Rsrq", DoubleValue(rsrq));
-        report->SetAttribute("IsServingCell", BooleanValue(isServingCell));
-        report->SetAttribute("ComponentCarrierId", UintegerValue(componentCarrierId));
-
-        m_reports.push_back(report);
-    }
-}
+  NS_LOG_FUNCTION(this << +rnti << +cellId << rsrp << rsrq
+                       << isServingCell << +componentCarrierId);
 
+  if (!m_active) return;
 
-std::vector<Ptr<OranReport>>
-OranReporterLteUeRsrpRsrq::GenerateReports()
-{
-    NS_LOG_FUNCTION(this);
+  NS_ABORT_MSG_IF(m_terminator == nullptr,
+                  "Attempting to generate reports in reporter with NULL E2 Terminator");
+
+  Ptr<OranReportLteUeRsrpRsrq> report = CreateObject<OranReportLteUeRsrpRsrq>();
 
-    std::vector<Ptr<OranReport>> reports;
+  // Keep attributes for base-class meta fields (these *do* exist as attributes)
+  report->SetAttribute("Time",             TimeValue(Simulator::Now()));
+  report->SetAttribute("ReporterE2NodeId", UintegerValue(m_terminator->GetE2NodeId()));
 
-    if (m_active)
-    {
-        reports = m_reports;
-        m_reports.clear();
-    }
+  // Use typed setters for payload (bypass reflection on "Rsrq")
+  report->SetRnti(rnti);
+  report->SetCellId(cellId);
+  report->SetRsrp(rsrp);
+  report->SetRsrq(rsrq);
+  report->SetIsServingCell(isServingCell);
+  report->SetComponentCarrierId(static_cast<uint16_t>(componentCarrierId));
+
+  m_reports.push_back(report);
+}
 
-    return reports;
+std::vector<Ptr<OranReport>>
+OranReporterLteUeRsrpRsrq::GenerateReports()
+{
+  NS_LOG_FUNCTION(this);
+
+  std::vector<Ptr<OranReport>> reports;
+  if (m_active)
+  {
+    reports = m_reports;
+    m_reports.clear();
+  }
+  return reports;
 }
 
 } // namespace ns3
+
